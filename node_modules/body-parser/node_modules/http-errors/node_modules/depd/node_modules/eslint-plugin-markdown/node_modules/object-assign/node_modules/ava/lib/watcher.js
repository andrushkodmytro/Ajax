'use strict';
var nodePath = require('path');
var debug = require('debug')('ava:watcher');
var diff = require('lodash.difference');
var chokidar = require('chokidar');
var flatten = require('arr-flatten');
var union = require('array-union');
var uniq = require('array-uniq');
var AvaFiles = require('ava-files');

function rethrowAsync(err) {
	// Don't swallow exceptions. Note that any expected error should already have
	// been logged.
	setImmediate(function () {
		throw err;
	});
}

function Watcher(logger, api, files, sources) {
	this.debouncer = new Debouncer(this);
	this.avaFiles = new AvaFiles({
		files: files,
		sources: sources
	});

	this.isTest = this.avaFiles.makeTestMatcher();

	this.clearLogOnNextRun = true;
	this.runVector = 0;
	this.run = function (specificFiles) {
		if (this.runVector > 0) {
			var cleared = this.clearLogOnNextRun && logger.clear();
			if (!cleared) {
				logger.reset();
				logger.section();
			}
			this.clearLogOnNextRun = true;

			logger.reset();
			logger.start();
		}

		var currentVector = this.runVector += 1;

		var runOnlyExclusive = false;

		if (specificFiles) {
			var exclusiveFiles = specificFiles.filter(function (file) {
				return this.filesWithExclusiveTests.indexOf(file) !== -1;
			}, this);

			runOnlyExclusive = exclusiveFiles.length !== this.filesWithExclusiveTests.length;

			if (runOnlyExclusive) {
				// The test files that previously contained exclusive tests are always
				// run, together with the remaining specific files.
				var remainingFiles = diff(specificFiles, exclusiveFiles);
				specificFiles = this.filesWithExclusiveTests.concat(remainingFiles);
			}
		}

		var self = this;
		this.busy = api.run(specificFiles || files, {
			runOnlyExclusive: runOnlyExclusive
		}).then(function (runStatus) {
			runStatus.previousFailCount = self.sumPreviousFailures(currentVector);
			logger.finish(runStatus);

			var badCounts = runStatus.failCount + runStatus.rejectionCount + runStatus.exceptionCount;
			self.clearLogOnNextRun = self.clearLogOnNextRun && badCounts === 0;
		}, rethrowAsync);
	};

	this.testDependencies = [];
	this.trackTestDependencies(api, sources);

	this.filesWithExclusiveTests = [];
	this.trackExclusivity(api);

	this.filesWithFailures = [];
	this.trackFailures(api);

	this.dirtyStates = {};
	this.watchFiles();
	this.rerunAll();
}

module.exports = Watcher;

Watcher.prototype.watchFiles = function () {
	var self = this;
	var patterns = this.avaFiles.getChokidarPatterns();

	chokidar.watch(patterns.paths, {
		ignored: patterns.ignored,
		ignoreInitial: true
	}).on('all', function (event, path) {
		if (event === 'add' || event === 'change' || event === 'unlink') {
			debug('Detected %s of %s', event, path);
			self.dirtyStates[path] = event;
			self.debouncer.debounce();
		}
	});
};

Watcher.prototype.trackTestDependencies = function (api) {
	var self = this;
	var isSource = this.avaFiles.makeSourceMatcher();

	var relative = function (absPath) {
		return nodePath.relative('.', absPath);
	};

	api.on('test-run', function (runStatus) {
		runStatus.on('